### 人工智能认知观

人工智能的各种认知观指的是对于人工智能系统如何**实现认知能力**的不同观点和理论。这些认知观主要涉及到人工智能在模仿人类认知过程、实现智能行为以及理解和解释世界等方面的方法和理论。以下是几种常见的人工智能认知观：

1. **符号主义认知观**（symbolicism）：(侧重模拟功能)符号主义认知观基于符号处理的思想，认为人工智能可以通过使用**符号和规则**来模拟人类的认知过程。它强调符号的表示和处理，**通过逻辑推理和符号操作来实现智能行为**。经典的人工智能（经典AI）采用了符号主义认知观的思想。(主要是数理统计)
2. **连接主义认知观**（connectionism)：(侧重模拟结构)连接主义认知观强调**神经网络和大规模并行分布式处理**的思想。它模拟人脑中神经元之间的连接和信息传递，**通过学习和调整权重来实现智能行为**。连接主义认知观在机器学习和深度学习领域得到了广泛应用。
3. **行为主义认知观**（actionism）：(侧重模拟方法)行为主义认知观关注人工智能系统的外部行为和反馈，认为智能可以**通过学习和适应环境来实现**。它强调基于**输入和输出的条件反射和学习**，通过观察和分析行为来推断智能的存在。

4. 动态系统认知观：动态系统认知观认为智能是由于复杂的动态系统的演化产生的，强调系统的自组织性、非线性和复杂性。它关注智能行为的发展和演化过程，认为智能是由系统与环境相互作用和适应的结果。
5. 意识认知观：意识认知观探讨人工智能系统是否能够获得类似于人类意识的主观体验和内在感知。它涉及到对主观体验、自我意识和理解世界的深层次认知的研究。意识认知观在哲学和认知科学领域引起了广泛的讨论和争议。

需要注意的是，这些认知观并不是相互排斥的，往往可以结合使用。在人工智能的发展过程中，不同的认知观可以提供不同的思路和方法，推动人工智能技术的进步和创新。

下面是对以上各种认知观下的标志算法和应用的详细说明：

1. 符号主义认知观：
   - 标志算法：基于**逻辑推理和符号处理**的算法，如专家系统、规则引擎、语义网络等。
   - 应用：专家系统在医学诊断、金融风险评估等领域具有广泛应用。规则引擎用于业务流程管理、决策支持系统等。

2. 连接主义认知观：
   - 标志算法：神经网络算法，如多层感知机（MLP）、卷积神经网络（CNN）、循环神经网络（RNN）等。
   - 应用：神经网络算法广泛应用于图像识别、语音识别、自然语言处理、机器翻译等领域。

3. 行为主义认知观：
   - 标志算法：基于学习和反馈的算法，如强化学习、马尔可夫决策过程（MDP）等。
   - 应用：强化学习在机器人控制、游戏玩法优化、自适应系统等方面有广泛应用。

4. 动态系统认知观：
   - 标志算法：复杂系统建模和仿真算法，如复杂网络模型、进化算法、粒子群优化等。
   - 应用：复杂网络模型在社交网络分析、交通流量优化等方面应用广泛。进化算法和粒子群优化用于解决优化问题。

5. 意识认知观：
   - 标志算法：对于意识的研究尚处于探索阶段，没有明确的标志算法。
   - 应用：意识认知观的研究主要集中在哲学和认知科学领域，尚未有明确的应用。

需要注意的是，人工智能的发展是一个综合运用多种算法和方法的过程。不同的认知观可以在实际应用中相互融合和交叉，创造出更强大和智能的系统。此外，随着人工智能技术的不断进步，新的算法和应用也在不断涌现。

### 人工智能系统类别

按照作用原理，可以将智能系统的各种类别分为以下几类，并对它们的发展历史和系统特点进行详细解释：

1. 专家系统（Expert Systems）：
   - 发展历史：专家系统起源于**20世纪60年代末至70年代初**的人工智能研究，是早期人工智能系统的代表。
   - 系统特点：专家系统通过存储和运用领域专家的知识来解决复杂问题。它们使用规则和推理机制，模拟人类专家的决策过程，具备高度的推理和解释能力。

2. 机器学习系统（Machine Learning Systems）：
   - 发展历史：机器学习是人工智能领域的重要分支，起源于**20世纪50年代**的神经网络和统计学习理论。
   - 系统特点：机器学习系统通过从数据中学习模式和规律来进行决策和预测。它们使用**统计方法和算法**，自动从大量数据中提取特征，并通过训练和优化模型来实现智能行为。机器学习系统可以分为**监督学习、无监督学习和强化学习等不同类型**。

3. 神经网络系统（Neural Network Systems）：
   - 发展历史：神经网络系统起源于**20世纪40年代**的神经科学研究，是**连接主义和深度学习的基础**。
   - 系统特点：神经网络系统模拟了人脑神经元之间的连接和信号传递方式。它们由多层神经元组成，通过学习和调整连接权重来实现模式识别和学习能力。深度学习是神经网络系统的一个重要分支，能够处理大规模数据和复杂任务。

4. 进化算法系统（Evolutionary Algorithm Systems）：
   - 发展历史：进化算法起源于**20世纪60年代**的**遗传算法研究**，受到达尔文进化论的启发。
   - 系统特点：进化算法系统通过**模拟生物进化的过程来搜索最优解**。它们使用基因编码和遗传操作（如交叉和变异）进行种群的进化和优化，能够应用于复杂优化问题和设计任务。

5. 混合智能系统（Hybrid Intelligent Systems）：
   - 发展历史：混合智能系统结合了多种智能技术和方法，以克服单一方法的局限性。
   - 系统特点：混合智能系统综合了不同原理和方法的优点，提供更强大、全面的智能能力。它们可以将专家系统、机器学习、神经网络、进化算法等技术进行集成，以应对复杂多变的问题和任务。

这些智能系统类别在不同领域和应用中具有广泛的应用。它们的发展历史和系统特点不断推动着智能技术的进步和应用的拓展。随着研究的深入和技术的交叉融合，未来智能系统可能会进一步发展出新的类别和方法，以应对更加复杂和挑战性的问题。

以下是一个所述智能系统的优缺点的表格：

| 智能系统类别 | 优点                                                         | 缺点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 专家系统     | - 高度推理和解释能力<br>- 可以存储和应用领域专家的知识<br>- 可以处理复杂问题 | - 需要大量的专家知识和规则<br>- 对**知识表示和更新的需求较高**<br>- 缺乏灵活性和通用性 |
| 机器学习系统 | - 自动从数据中学习模式和规律<br>- 可以处理大规模数据和复杂任务<br>- 具备泛化和适应性 | - 需要大量标注和训练数据<br>- 模型的**解释性较差**<br>- 对**数据质量和分布的依赖较高** |
| 神经网络系统 | - 具备强大的模式识别和学习能力<br>- 可以处理大规模数据和复杂任务<br>- 并行计算能力强 | - 对网络结构和超参数的调整较为困难<br>- 需要**大量的计算资源**<br>- 模型的解释性较差 |
| 进化算法系统 | - 可以应用于复杂优化问题和设计任务<br>- 具备**全局搜索和优化能力**<br>- 可以处理**非连续、非凸**的问题 | - 需要较长的时间进行进化和优化<br>- 对问题的建模和编码较为复杂<br>- 结果的质量受到随机性和参数选择的影响 |
| 混合智能系统 | - 综合多种技术和方法，提供更强大的智能能力<br>- 可以弥补单一方法的局限性<br>- 适应多样化的问题和任务 | - 需要整合不同技术的复杂性和挑战<br>- 对系统的设计和整合要求较高<br>- 可能增加系统的复杂性和开发成本 |

请注意，以上表格仅列出了智能系统的一些典型优缺点，实际情况可能因具体应用和实施方式而有所不同。

### 知识表示方法

知识是一个抽象的术语，尝试描述人对某种特定对象的理解。根据不同任务和不同的知识类型，有不同的知识表示方法，对应这许多不同的方法和技术可供选择（**不同知识表示方法，在求解问题方法和效率也不太同，需要考虑**）。以下是一些常见的知识表示方法极少（需要注意的是这里的知识表示方法，不仅仅是面对现在主流大热的人工智能方向，几乎是包含了全部的人工智能方向，机器智能其实就是我们日常解决的问题，例如八数码问题、圆盘梵塔难题都可以很好求解，这种方法论在面对数据结构与算法中也是非常有效的，可以说是秘籍）

| 名称                                     | 介绍                                                         | 实际案例                                                     |
| ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 状态空间法（State Space Representation） | 状态空间法是一种基于状态和操作的知识表示方法，常用于解决问题求解和规划的任务。在状态空间中，问题被表示为一组可能的状态和转换操作。每个状态表示问题的某个特定情况，而操作表示从一个状态到另一个状态的转换。通过定义状态和操作之间的关系，可以进行搜索或规划来找到问题的解决方案。状态空间法适用于涉及状态转换和路径搜索的问题。 | 例如，迷宫问题可以使用状态空间法来表示。每个状态表示迷宫的特定位置，操作表示在迷宫中移动的动作。通过搜索路径来找到从起点到终点的解决方案。 |
| 问题归约法（Problem Reduction）          | 问题归约法是一种将复杂问题转化为相对简单问题的知识表示方法。在问题归约中，复杂问题被分解为一系列更小、更易解决的子问题。每个子问题可以使用已有的解决方法来解决，然后将这些解决方案组合起来解决原始问题。问题归约法有助于简化复杂问题的求解过程，并利用已有的解决方案来解决新问题。 | 例如，旅行推销员问题可以使用问题归约法来解决。该问题可以分解为多个子问题，例如确定城市之间的最短路径和选择下一个要访问的城市。每个子问题可以使用已有的路径搜索算法和决策方法来解决，然后将它们组合起来得到整体的解决方案。 |
| 谓词/符号逻辑（Symbolic Logic）          | 符号逻辑是一种基于形式化逻辑的知识表示方法。它使用符号和规则来表示和推理关于世界的知识。符号逻辑适用于处理明确和确定的知识。 | 例如，专家系统使用符号逻辑来表示和推理关于特定领域知识的规则，如医疗诊断和法律推理。 |
| 语义网络（Semantic Networks）            | 语义网络使用节点和连接线的图形结构来表示知识。节点表示实体或概念，连接线表示它们之间的关系。语义网络可以表示丰富的语义关系。 | 例如，WordNet是一个语义网络，用于表示单词之间的同义词、上位词和下位词等关系。 |
| 产生式规则（Production Rules）           | 产生式规则采用“如果-那么”形式的规则表示知识。每个规则包含条件部分和动作部分。当条件部分匹配时，执行相应的动作。 | 例如，专家系统中的规则库使用产生式规则来推理和解决问题，如诊断疾病和故障排除。 |
| 本体技术（Ontology）                     | 本体是一种形式化的知识表示方法，用于描述实体之间的概念和关系。本体使用类、属性和关系来定义领域的概念和属性。 | 例如，医学领域的本体可以定义疾病、症状和治疗方法之间的关系，以支持医学知识的共享和推理。 |
| 向量空间模型（Vector Space Model）       | 向量空间模型将文本或概念表示为高维向量空间中的向量。向量之间的距离和相似度捕捉了文本或概念之间的关系。 | 例如，文本分类任务中使用的词袋模型将文本表示为向量，以便进行分类和聚类。 |
| 神经网络（Neural Networks）              | 神经网络是一种模仿人脑神经系统结构和功能的知识表示方法。它通过学习从输入到输出的映射关系来表示知识。 | 例如，卷积神经网络（CNN）用于图像识别任务，循环神经网络（RNN）用于自然语言处理和语音识别任务。 |
| 图神经网络（Graph Neural Networks）      | 图神经网络是一种用于处理图数据的神经网络。它学习节点之间的关系和图的结构来表示知识。 | 例如，社交网络分析中使用的图神经网络可以推断社交关系和预测用户行为。 |

#### 状态空间法（State Space Representation）

这里以传教士与野人的问题为例：

> 设有3个传教士和3个野人来到河边，打算乘一条船从右岸渡到左岸去。该船的负载能力为两人。在任何时候,如果野人人数超过传教士人数,那么野人就会把传教士吃掉。如何用状态空间法来表示该问题?给出具体的状态表示和算符。

根据状态空间法，我们首先需要定义其对于状态，而后定义操作。

在这个问题中，我们可以使用状态空间搜索来解决。我们可以用一组状态来表示传教士和野人在不同岸边的位置。

状态表示：
1. 用 `(M, C, B)` 表示一个状态，其中 `M` 表示右岸的传教士数量，`C` 表示右岸的野人数量，`B` 表示船的位置，`B = 0` 表示船在右岸，`B = 1` 表示船在左岸。

算符表示：

`(m, c)`: 将m个传教士和c个野人从右岸乘船到左岸，。前提条件是 `m + c <= 2` 。

这些算符表示了允许的合法移动，同时满足传教士和野人数量的限制条件。通过在状态空间中搜索，我们可以找到一条路径，使得所有传教士和野人都能安全地从右岸渡到左岸。

参考：

<img src="core%20concept.assets/7be02d8c5512422386852cdab73f55c6.png" alt="请添加图片描述" style="zoom: 25%;" />

再举一个例子

> 利用下图,用状态空间法规划一个最短的旅行路程:此旅程从城市 A 开始，访问其他城市不多于一次,并返回 A。选择一个状态表示,表示出所求得的状态空间的节点及弧线,标出适当的代价,并指明图中从起始节点到目标节点的最佳路径。
>
> <img src="core%20concept.assets/image-20231209153109401.png" alt="image-20231209153109401" style="zoom:33%;" />

用 `(M, C, B)` 表示一个状态，其中 `M` 表示初始城市，`C` 表示目标城市，`B` 表示距离。

需要找到从起始节点A到目标节点A的最佳路径。这可以通过应用最短路径算法（例如迪杰斯特拉算法或暴力枚举算法）来实现，平时用迪杰斯特拉算法即可。

#### 语义网络（Semantic Networks）

由奎廉（Quillian）于1968年提出，作为描述人类联想记忆的一种心理学模型。

语义网络的结构定义

> 语义网络是知识的一种图解表示，它由节点和弧线或链线组成。节点用于表示实体、概念和情况等，弧线用于表示节点间的关系。
>
> <img src="core%20concept.assets/image-20231211170434940.png" alt="image-20231211170434940" style="zoom:50%;" />

我们根据以下这个例子简单讲解

> 把下列语句表示成语义网络描述:
> (1) All men are mortal.
> (2) Every cloud has a silver lining.
> (3) All branch managers of DEC participate in a profit-sharing plan.

下面是将给定语句表示为语义网络的描述：

(1) All men are mortal.
   语义网络描述：

   - 点（节点）：人（Men）
   - 连接（关系）：无
   - 属性（特征）：有生命（Mortal）

![image-20231209161717395](core%20concept.assets/image-20231209161717395.png)

(2) Every cloud has a silver lining.
   语义网络描述：

   - 点（节点）：云（Cloud）、边（Lining）
   - 连接（关系）：有（has）
   - 属性（特征）：颜色（Silver ）

​	![image-20231209161952067](core%20concept.assets/image-20231209161952067.png)

(3) All branch managers of DEC participate in a profit-sharing plan.
   语义网络描述：
   - 点（节点）：经理（Managers）、计划（plan)
   - 连接（关系）：参与（participate in）
   - 属性（特征）：DEC、利润分享（Profit-sharing）、分支（Branch )

![image-20231209162004608](core%20concept.assets/image-20231209162004608.png)

请注意，语义网络描述的形式可以有所不同，上述描述仅提供了一种可能的表示方法。

#### 问题归约法（Problem Reduction）

问题归约(problem reduction)是另一种基于状态空间的问题描述与求解方法。已知问题的描述,通过一系列变换把此问题最终变为一个本原问题集合;这些本原问题的解可以直接得到，从而解决了初始问题

 问题归约表示的组成部分：

- 一个初始问题描述；
- 一套把问题变换为子问题的操作符；
- 一套本原问题描述。

> 问题归约的实质：
> 从目标(要解决的问题)出发**逆向推理**，建立子问题以及子问题的子问题，直至最后把初始问题**归约为一个平凡的本原问题集合**。

下面是问题归约法的一般步骤：

1. 确定目标问题：明确要解决的原始问题是什么，以及需要得到的解决方案是什么。
2. 识别子问题：分析原始问题，并确定可以将其分解为哪些较简单的子问题。子问题应该与原始问题相关，并且解决子问题可以为解决原始问题提供有用的信息。
3. 定义转换规则：确定如何将原始问题转化为子问题。这包括定义问题之间的关系和转换过程，以确保转换后的子问题仍然保持原始问题的特性。
4. 解决子问题：使用合适的方法或技术解决子问题。这可能涉及使用特定的算法、数学模型、启发式搜索等。
5. 合并子问题的解：将子问题的解整合在一起，以得到原始问题的解。这可能需要将子问题的解进行组合、合并或进一步处理。
6. 验证和优化解决方案：对得到的解决方案进行验证，确保它满足原始问题的要求。如果需要，可以对解决方案进行优化或调整。

我们以圆盘梵塔难题为例，

> 有3个柱子(1,2和3)和3个不同尺寸的圆盘(A,B和C)。在每个圆盘的中心有个孔,圆盘可以堆叠在柱子上。最初,全部3个圆盘都堆在柱子1上:最大的圆盘 C在底部,最小的圆盘A在顶部。要求把所有圆盘都移到柱子3上,每次只许移动一个,而且只能先搬动柱子顶部的圆盘,还不许把尺寸较大的圆盘堆放在尺寸较小的圆盘上。这个问题的初始配置和目标配置如图 2.3所示。
> 如果采用状态空间法来求解这个问题,其状态空间图含有 27个节点，每个节点代表柱子上圆盘的一种正当配置。

<img src="core%20concept.assets/image-20231211163319205.png" alt="image-20231211163319205" style="zoom:50%;" />

也可以用问题归约法来求解此问题。对图所示的原始问题从目标出发逆向推理，其过程如下;
	(1)要把所有圆盘都移至柱子3,必须首先把圆盘C移至柱子3;而且在移动圆盘C至柱子3之前,要求柱子3必须是空的。
	(2)只有在移开圆盘A和B之后,才能移动圆盘 C;而且圆盘A和B最好不要移至柱子3,否则就不能把圆盘 C移至柱子3。因此,首先应该把圆盘 A和B移到柱子2上。
	(3)然后才能够进行关键的一步,把圆盘C从柱子1移至柱子3,并继续解决难题的其余部分。

<img src="core%20concept.assets/image-20231211164648389.png" alt="image-20231211164648389" style="zoom:50%;" />

梵塔问题归约图（与或图）如下（用三元空间来描述问题）

<img src="core%20concept.assets/image-20231211165725144.png" alt="image-20231211165725144" style="zoom:50%;" />

> **归约图（与或图）解释**
>
> 一些关于与或图的术语
>
> <img src="core%20concept.assets/image-20231211165624511.png" alt="image-20231211165624511" style="zoom:50%;" />
>
> **可解节点的一般定义**
>
>  `终叶节点是可解节点`(因为它们与本原问题相关联)，
>
> 如果某个非终叶节点含有**或**后继节点，那么只要有一个后继节点是可解的时，此非终叶节点就是可解的。
> 如果某个非终叶节点含有**与**后继节点，那么只有其全部后继节点为可解时，此非终叶节点才是可解的。
>
> **不可解节点的一般定义**
> 没有后裔的非终叶节点为不可解节点
>
> 如果某个非终叶节点含有**或**后继节点，那么只有当其全部后裔为不可解时，此非终叶节点才是不可解的。
> 如果某个非终叶节点含有**与**后继节点，那么只要好当其后裔有一个为不可解时，此非终叶节点就是不可解的。

#### 谓词/符号逻辑（Symbolic Logic）

**逻辑语句**：一种形式语言，它能够把逻辑论证符号化，并用于证明定理，求解问题。
**形式语言**：严格地按照相关领域的特定规则，以数学符号（符号串）形式描述该领域有关客体的表达式。

**语法和语义**
基本符号：谓词符 号、变量符号、函数符号、 常量符号、括号和逗号

<img src="core%20concept.assets/image-20231211165454263.png" alt="image-20231211165454263" style="zoom: 50%;" />

在求解问题时,可把问题表示为一个有待证明的问题或定理,然后用消解原理和消解反演过程来证明。

在证明时,采用推理规则进行正向搜索, 使问题(定理)最终获得证明。另一种策略是采用反演证明来证明某个定理的否定是不成立的。首先假定该定理的否定是正确的,接着证明由公理和假定的定理之否定所组成的集合是不成立的，即导致矛盾的结论

通过逻辑推理和运用消解原理来求解证明。我们首先需要用谓词进行知识表示，以下是一个谓词的例子

> 设有如下语句，请用相应的谓词公式分别把他们表示出来 （**要注意属性、行为、个体的区别**）
>
> 1）有人每天下午都去打篮球。
>
> 2）有的人喜欢梅花，有的人喜欢菊花，有的人既喜欢梅花又喜欢菊花

1.) 有人每天下午都去打篮球。

​    解：定义谓词 P(x)：

x是人 B(x)：x打篮球 A(y)：y是下午 

  将知识用谓词表示为：![img](core%20concept.assets/903774-20160417142157520-1256511146.jpg)(A(y)→B(x)∧P(x)) 

2.) 老李每天下午都去打篮球。

解:定义谓词 d

P(x): x是人
L(x,y): x喜欢 y
其中，**y 的个体域是(梅花，菊花)**(注意个体域)

将知识用谓词表示为 :

$(Ex)(P(x)->L(x,梅花) ∨ L(x,菊花)∨ L(x,梅花)∧ L(x,菊花)) $

在更复杂的问题，我们需要掌握用消解/归结原理得到目标公式，消解是一种可用于一定的子句公式的重要推理规则，（**对谓词演算公式进行分解和化简，消去一些符号，以求得导出子句,又称归结**。）

> 以下是一些基本定义
>
> **子句**：由文字的析取组成的合式公式。
>
> **文字**：一个原子公式及其否定。

**任一谓词演算公式可以化成一个子句集**。变换过程如下：

1. 消去蕴涵符号
   只应用∨和∼，以∼ A ∨ B替换 A→B
2. 减少否定符号的辖域
   每个否定符号最多只用到一个谓词符号上，并反复应用狄⋅ 摩根定律
3. 对变量标准化
   在任一量词辖域内，受该量词约束的变量称为一哑元（虚构变量），它可以在该辖域内处处统一的被另一个没有出现过的任意变量所代替，而不改变公的真值。
   合式公式中变量的标准化意味着对哑元改名以保证每个量词都有其唯一的哑元
4. 消去存在量词
   从一个公式消去一个存在量词的一般规则是以一个Skolem函数1代替每个出现的存在量词的量化变量，而这个Skolem函数的变量就是由那些全称量词所约束的全称量词量化变量，这些全称量词的辖域包括要被消去的存在量词的辖域在内
   如果要消去的存在量词不在任何一个全称量词的辖域内，那么就用不含变量的Skolem函数即常量
   Skolem函数所使用的函数符号必须是新的
5. 化为前束型
   把所有全称量词移到公式的左边，并使每个量词的辖域包括这个量词后面公式的整个部分，所得公式称为前束型。前束型公式由前缀和母式组成，前缀由全称量词串组成，母式由没有量词的公式组成
6. 把母式化为合取范式
   任何母式都可写成由一些谓词公式和谓词公式的否定的析取的有限集组成的合取，这种母式叫做合取范式
7. 消去全称量词
8. 消去连词符号∧ 
   用{ A , B } 代替( A , B ) (A,B)(A,B)，以消去∧ 
9. 更换变量名称
   可以更换变量符号的名称，使一个变量符号不出现在一个以上的子句中

以下是基本定律（联接词的优先顺序：**非～、合取∧、析取∨、蕴含**）

> (1) 否定之否定：         ～(～P)等价于P
> (2) P∨Q等价于～P=>Q
> (3) 狄·摩根定律：       ～(P∨Q)等价于～P∧～Q
>                                   ～(P∧Q)等价于～P∨～Q
> (4) 分配律：               P∧(Q∨R)等价于(P∧Q)∨(P∧R)
>                                   P∨(Q∧R)等价于(P∨Q)∧(P∨R)
> (5) 交换律：               P∧Q等价于Q∧P
>                                   P∨Q等价于Q∨P
> (6) 结合律：               (P∧Q)∧R等价于P∧(Q∧R)
>                                  (P∨Q)∨R等价于P∨(Q∨R)
> (7) 逆否律：              P=>Q等价于～Q=>～P
>
> (8) ～(∃x)P(x)  等价于  (∀ x)［～P(x)］
>    ～(∀ x)P(x)  等价于  (∃ x)［～P(x)］
>
> (9) (∀ x)［P(x)∧Q(x)］ 等价于      (∀ x)P(x)∧(∀ x)Q(x)
>    (∀ x)［P(x)∨Q(x)］ 等价于      (∀ x)P(x)∨(∀ x)Q(x)
>
> (10)  (∀ x)P(x)  等价于  (∀ y)P(y)
>       (∃ x)P(x)  等价于  (∃ y)P(y)

得到子句集后后续有三个重要的问题求解方法需要重点掌握

1. 消解推理规则（根据已有的式子析取推理）
2. 含有变量的消解式（根据基子句推理的推广、原理一样，需要额外使变量相等）
3. 消解反演求解过程（将要证明的命题，将其否定添加到命题公式集，如产生矛盾为真、否则为假）

消解反演求解例子一（证明一个子句）：

设事实的公式集合
    { P，(P∧Q) $\rightarrow$ R，
        (S∨T) $\rightarrow$ Q，T }, 
     证明：R

  否定结论 ，将公式化为子句，得子句集：
{ P，～P∨～ Q∨R，
   ～S∨Q，～ T∨Q ，T ， 
    ～R }

这里除了用列出结论之外还可以用消解反演树

<img src="core%20concept.assets/image-20231211194330594.png" alt="image-20231211194330594" style="zoom:50%;" />

> **消解反演：**
>
> 给出一个公式集合S 和目标公式L，**通过反证或反演来求证目标公式 L** ，其证明步骤如下：
>
> 否定L，得∼ L
> 把∼ L添加到S 中
> 把新产生的集合{ ∼ L , S } 化成子句集
> 应用消解原理，推导出一个表示矛盾的空子句
>
> **反演求解过程：**
> 用反演树求取对某个问题的答案
>
> 1. 把由目标公式的否定**产生的每个子句**添加到目标公式否定之否定的子句中，形成重言式
> 2. 按照反演树，**执行和以前相同的消解**，直至在根部得到某个子句为止
> 3. **用根部的子句作为一个回答语句**
>
> 答案求取涉及把一棵根部有NIL的反演树变换为在根部带有可用答案的某个语句的一棵证明树

再来一个例子（反演求解 证明一个公式），建议动手做做

> 已知
>
> 1）能够阅读的都是有文化的。
>
> 2）海豚是没有文化的。
>
> 3）**某些海豚是有智能的。** (注意这里是没有前置的属性,所以是合取)
>
> 用归结原理证明：某些 有智能的并不能阅读。

解 

```
证明:
 
已知谓词:R（x）表示x能阅读, L(x)表示有文化，D（x）表示x是海豚，I（x）表示智慧的。
 
 
 
则将条件与目标用谓词公式表示：
 
(1) ∀x(R(x)→L(x))
 
(2) ∀x(D(x)→¬L(x))
 
(3) ∃x(D(x)∧I(x))
 
把要求证的结论用谓词公式表示出来并否定，得：
 
(4) ∃x(I(x)∧¬R(x))
 
 
把上述公式化成子句集：
 
(1) ¬R(x)∨L(x)
 
(2) ¬D(y)∨¬L(y)
 
(3) D(a)
 
(4) I(a)
 
(5) ¬I(z)∨R(z)
 
应用归结原理进行归结：
 
(6) ¬L(a)      (2),(3)归结
 
(7) ¬R(a)      (1),(6)归结
 
(8) R(a)       (4),(5)归结
 
(9) NIL        (7),(8)归结
```

### 图搜搜策略

根据上文的知识表示方法之后，其作为问题求解所必需的步骤，将问题表示出来，在求解过程中，可通过搜索技术进行求解，

> 需要一个图和两个辅助数据结构 -  OPEN表和CLOSED表（其中启发式信息用于重排OPEN表，也可以根据此判断是否启发式搜索）
>
> 必须记住下一步还可以走哪些点`OPEN表(记录还没有扩展的点)`
>
> 必须记住哪些点走过了`CLOSED表(记录已经扩展的点)`
>
> 必须记住从目标返回的路径`每个表示状态的节点结构中必须有指向父节点的指针`

不同的估价函数定义对应于不同的算法
	$	f (x) = g (x) + h (x)$
$h (x)=0$：UCS，非启发式算法
$g (x)=0$：贪婪搜索，无法保证找到解（一般为初始的深度）
即使采用同样的形式$f (x) = g (x) + h (x) $，不同的定义和不同的值也会影响搜索过程

#### 无信息/盲目搜索

| 名称                                | 介绍                                                         | 实际案例                                                     |
| :---------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 深度优先搜索 (Depth-First Search)   | 深度优先搜索是一种图搜索策略，它从起始节点开始，沿着一条路径一直深入搜索，直到达到最深的节点，然后回溯到前一个节点继续搜索。 | 实际案例是使用深度优先搜索来解决迷宫问题，其中每个节点表示迷宫中的一个位置，连接表示可以移动的路径，目标是找到从起始位置到达目标位置的路径。 |
| 广度优先搜索 (Breadth-First Search) | 广度优先搜索是一种图搜索策略，它从起始节点开始，逐层地向外扩展搜索，直到找到目标节点为止。它按照节点的距离从起始节点逐层扩展，保证找到的路径是最短路径。 | 实际案例是使用广度优先搜索来解决社交网络中的最短路径问题，其中每个节点表示一个人，连接表示人与人之间的关系，目标是找到两个人之间的最短路径。 |
| 等代价搜索 (Uniform Cost Search)    | 等代价搜索是一种启发式搜索策略，它在搜索过程中考虑到每个状态的路径代价，并选择代价最小的状态进行扩展。它可以用于解决具有不同代价的操作或路径的问题。 | 实际案例是使用等代价搜索来解决路径规划问题，其中每个状态表示地图上的一个位置，连接表示移动操作，每个连接具有不同的代价。搜索算法会选择代价最小的路径，以找到从起始位置到目标位置的最优路径。 |

一般来说这个盲目搜索可以用于生活场景，比如找东西，一般来说最好的效率是

有界深度优先搜索 - 》 宽度优先搜索 -》深度优先搜索

##### 深度优先搜索 (Depth-First Search)

这里以八数码难题为例，深度优先搜索则需要设定深度界限，以下设置为5，其中节点旁边的数字表示节点扩展的顺序

<img src="core%20concept.assets/image-20231210155755425.png" alt="image-20231210155755425" style="zoom:50%;" />

##### 广度优先搜索 (Breadth-First Search)

这里以八数码难题为例，即搜索到目标状态就停止，其中节点旁边的数字表示节点扩展的顺序

<img src="core%20concept.assets/image-20231210155732389.png" alt="image-20231210155732389" style="zoom: 50%;" />

##### 等代价搜索 (Uniform Cost Search)

等代价搜索就是加了相应的代价的宽度优先搜索（这里以路径为例）

<img src="core%20concept.assets/GIF%202023-12-11%2019-33-48.gif" alt="GIF 2023-12-11 19-33-48" style="zoom:50%;" />

#### 启发式搜索

盲目搜搜效率低下，耗费过多空间与时间，我们将采用启发式信息来改进搜索策略（某些准则或经验），其中在启发式搜索策略中的估价函数（Heuristic Function）是一种用于评估当前状态与目标状态之间的距离或优劣的函数。它提供了启发信息，帮助搜索算法在搜索空间中优先考虑最有希望的路径。以下是几种常见的估价函数算法：

1. 曼哈顿距离（Manhattan Distance）：曼哈顿距离是一种在网格状环境中常用的估价函数算法，用于评估当前状态与目标状态之间的距离。它计算两个状态在水平和垂直方向上的距离之和，忽略斜向距离。曼哈顿距离通常用于路径规划问题，如在城市地图中计算两个位置之间的最短路径。
2. 欧几里得距离（Euclidean Distance）：欧几里得距离是一种在连续空间中常用的估价函数算法，用于评估当前状态与目标状态之间的距离。它计算两个状态之间的直线距离，即两个状态之间的欧几里得距离。欧几里得距离在图像处理、机器人路径规划等领域中经常使用。
3. 启发式规则（Heuristic Rules）：启发式搜索中的估价函数可以基于特定问题的启发式规则进行定义。这些规则可以利用问题领域的先验知识来评估当前状态与目标状态之间的优劣。例如，在八数码拼图问题中，可以定义一个估价函数，计算当前状态与目标状态之间不匹配的数字个数作为估计的代价。
4. 模式数据库（Pattern Databases）：模式数据库是一种用于解决问题的启发式搜索算法，特别适用于状态空间较大的问题。它使用预先计算的模式数据库来评估状态的优劣。模式数据库记录了特定模式的状态和目标状态之间的最小代价。通过查询模式数据库，可以快速获得当前状态的估计代价。
5. 机器学习方法：在一些复杂的问题中，可以使用机器学习方法来学习估价函数。通过训练算法使用大量的样本数据，它可以学习从当前状态到目标状态的最优路径，并生成一个能够评估状态优劣的估价函数。

这里在生活场景也是一样，在找东西优先找相关的场景

##### 有序搜索 / 最佳优先搜索

最佳优先搜索（Best-First Search）是一种常用的图搜索算法，它在图或树的搜索过程中，根据每个节点的启发式评估函数（heuristic evaluation function）来决定下一个被扩展的节点。

以下是最佳优先搜索的详细步骤：

1. 初始化：将起始节点放入一个优先级队列（priority queue）中，队列中的元素按照启发式评估函数的值进行排序，其中值越小的节点优先级越高。
2. 迭代扩展节点：重复以下步骤直到找到目标节点或队列为空：
   - 从队列中选择优先级最高的节点，并将其从队列中移除。
   - 检查当前节点是否为目标节点，如果是则搜索结束，找到了目标。
   - 如果当前节点不是目标节点，则将其所有邻居节点加入队列中，并根据启发式评估函数的值重新排序队列。
3. 如果队列为空但仍未找到目标节点，则表示搜索失败，图中不存在从起始节点到目标节点的路径。

在最佳优先搜索中，启发式评估函数是关键。它用于估计从当前节点到目标节点的代价或距离，以指导搜索过程中的节点扩展顺序。启发式评估函数应该具有以下特性：
- 一致性（Consistency）：对于任意两个相邻节点u和v，如果从u到v的实际代价为c，则启发式评估函数的值应满足：h(u) <= h(v) + c。也就是说，启发式评估函数的值不会低估实际代价。
- 乐观性（Optimistic）：启发式评估函数的值应该尽可能接近实际最小代价，以使搜索算法更加高效。

最佳优先搜索的时间复杂度取决于搜索空间的大小和启发式评估函数的计算代价。在最坏情况下，它可能需要遍历整个搜索空间，导致指数级的时间复杂度。然而，合理选择和设计启发式评估函数可以显著改善搜索效率。

需要注意的是，最佳优先搜索并不保证找到最短路径，因为它只关注当前节点的启发式评估函数值，而不考虑已经探索过的路径。如果要确保找到最短路径，可以使用其他算法，如A*算法，它结合了最佳优先搜索和Dijkstra算法的思想。

以下是一个有序搜索的例子，采用了简单的估价函数（越小越好）
$$
f(n) = d(n) + W(n)
$$
d(n) 表示深度，W(n)表示错放数字个数（其中如果只用d(n) 那么就是宽度优先，-d(n) 则是深度优先）

<img src="core%20concept.assets/image-20231211162520614.png" alt="image-20231211162520614" style="zoom:50%;" />

## 专家系统

专家系统是一个智能计算机程序系统，其内部含有大量的某个领域专家水平的知识与经验，能够利用人类专家的知识和解决问题的方法来处理该领域问题。

下面是一些常见的专家系统类型及其介绍、优缺点的列表：

| 名称                   | 介绍                                                         | 优缺点                                                       |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基于规则的专家系统     | 基于规则的专家系统使用一系列预定义的规则来进行推理和决策。这些规则通常由领域专家提供，规则形式化地表达了专家知识。在推理过程中，系统将根据规则库中的规则进行匹配和执行，从而得出结论或建议。 | 优点：<br>- 知识表示简单明确，易于理解和维护<br>- 可以对系统进行解释和调试<br>- 适用于具有确定性问题的领域<br>缺点：<br>- 难以处理不确定性和模糊性<br>- 规则库规模较大时，匹配和推理效率可能较低<br>- 需要依赖领域专家提供规则 |
| 基于案例的专家系统     | 基于案例的专家系统通过利用已有的案例库来进行推理和决策。系统将新的问题与案例库中的相似案例进行匹配，并根据类似案例的解决方案来生成推荐或决策。 | 优点：<br>- 可以利用已有的经验和案例知识<br>- 能够处理复杂的问题和不完全的信息<br>- 可以进行适应和学习<br>缺点：<br>- 需要大量的案例库和相似性度量方法<br>- 案例库中的知识表示和检索可能较为困难<br>- 对于没有类似案例的问题，推理效果可能有限 |
| 基于模型的专家系统     | 基于模型的专家系统使用领域模型来进行推理和决策。模型可以是数学模型、逻辑模型、统计模型等，用于表示领域知识和问题结构。系统根据模型进行推理和模拟，从而得出结论或预测。 | 优点：<br>- 可以处理复杂的问题和不确定性<br>- 模型提供了形式化的表示和推理方法<br>- 可以进行模型验证和分析<br>缺点：<br>- 模型的构建和维护可能较为复杂<br>- 对于某些领域，模型的建立可能需要大量的时间和资源<br>- 模型的正确性和准确性依赖于模型的质量和适用性 |
| 基于知识图谱的专家系统 | 基于知识图谱的专家系统使用图谱来表示和组织领域知识。知识图谱由实体、关系和属性组成，提供了一种灵活的知识表示形式。系统可以通过图谱的关系和推理规则来进行知识的挖掘和推理。 | 优点：<br>- 灵活的知识表示和组织方式<br>- 可以进行知识的联结和推理<br>- 适用于复杂的领域和关联知识的问题<br>缺点：<br>- 图谱的构建和维护可能较为复杂<br>- 对于大型图谱，推理效率可能较低<br>- 图谱的质量和完整性对系统的影响较大 |

以上是一些常见的专家系统类型，每种类型都有其适用的场景和优缺点。在实际应用中，选择合适的专家系统类型取决于问题的性质、可用的领域知领域知识以及系统需求等因素。	

<img src="core%20concept.assets/91d83a3cbe2b4d169ff40c350ec98364a84d3f31.webp" alt="浮选专家系统在大山选矿厂160 m3浮选流程中的应用_参考网" style="zoom:50%;" />

专家的知识 — 知识库

专家的思考方式 — 推理方式

专家的判断力 — 与推理方式结合，输出解决方案。

主要内容:

> Knowledge Base（知识库）
> Global Database（综合数据库）
>
> > Design of Initial Knowledge Base（设计初始知识库）
> >   Problem identification（问题知识化）
> >   Knowledge conceptualization（知识概念化）
> >   Concept formulization（概念形式化）
> >   Rule formulation（形式规则化）
> >   Rule validation（规则合法化）
>
> Reasoning Machine（推理机）
> Explanator（解释器）
> Interface（推理机）
